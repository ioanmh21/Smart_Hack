

let objects = ["path20-40-4-9-08-41", "path20-40-4-9-08-1", "path20-40-4-9-08-78", "path20-40-4-9-08-23", "path20-40-4-9-08-4", "path20-40-4-9-08-26", "path20-40-4-9-08-3", "path20-40-4-9-08-2", "path20-40-4-9-08-7", "path20-40-4-9-08-9", "path20-51-0-8-78", "path20-40-68-3-37", "path20-84-1-9-1", "path20-51-7-3-0", "path20-40-4-9-08", "path20-84-3-6-3", "path20-51-99-7-45", "path20-40-2-99-0", "path20-84-5-7-1", "path20-51-9-69-45", "path20-40-6-3-62", "path20-84-8-5-03", "path20-51-0-8-3", "path20-40-68-3-00", "path20-84-1-9-48", "path20-51-7-3-30", "path20-40-4-9-129", "path20-84-3-6-03", "path20-51-99-7-8", "path20-40-2-99-8", "path20-84-5-7-57", "path20-51-9-69-7", "path20-40-6-3-0", "path20-84-8-5-89", "path20-51-0-8-98", "path20-40-68-3-302", "path20-84-1-9-2", "path20-51-7-3-3", "path20-40-4-9-6", "path20-84-3-6-7", "path20-51-99-7-1", "path20-40-2-99-5", "path20-84-5-7-5", "path20-51-9-69-40", "path20-40-6-3-260", "path20-84-8-5-6", "path20-51-0-8-92", "path20-40-68-3-0", "path20-84-1-9-70", "path20-51-7-3-6", "path20-40-4-9-07", "path20-84-3-6-0", "path20-51-99-7-5", "path20-40-2-99-67", "path20-84-5-7-38", "path20-51-9-69-49", "path20-40-6-3-26", "path20-84-8-5-57", "path20-51-0-8-0", "path20-40-68-3-6", "path20-84-1-9-7", "path20-51-7-3-50", "path20-40-4-9-04", "path20-84-3-6-54", "path20-51-99-7-95", "path20-40-2-99-64", "path20-84-5-7-8", "path20-51-9-69-21", "path20-40-6-3-6", "path20-84-8-5-83", "path20-51-0-8-11", "path20-40-68-3-32", "path20-84-1-9-53", "path20-51-7-3-5", "path20-40-4-9-12", "path20-84-3-6-22", "path20-51-99-7-6", "path20-40-2-99-40", "path20-84-5-7-70", "path20-51-9-69-3", "path20-40-6-3-4", "path20-84-8-5-0", "path20-51-0-8-7", "path20-40-68-3-30", "path20-84-1-9-3", "path20-51-7-3-8", "path20-40-4-9-25", "path20-84-3-6-2", "path20-51-99-7-0", "path20-40-2-99-3", "path20-84-5-7-7", "path20-51-9-69-29", "path20-40-6-3-7", "path20-84-8-5-5", "path20-51-0-8-1", "path20-40-68-3-2", "path20-84-1-9-5", "path20-51-7-3-7", "path20-40-4-9-4", "path20-84-3-6-4", "path20-51-99-7-4", "path20-40-2-99-4", "path20-84-5-7-4", "path20-51-9-69-2", "path20-40-6-3-9", "path20-84-8-5-3", "path20-40-4-9-3", "path20-40-4-9-2", "path20-40-4-9-86", "path20-40-4-9-1", "path20-51-0-8", "path20-40-68-3", "path20-84-1-9", "path20-51-7-3", "path20-40-4-9", "path20-40-4-9-8", "path20-84-3-6", "path20-51-99-7", "path20-40-2-99", "path20-84-5-7", "path20-51-9-69", "path20-40-6-3", "path20-84-8-5", "path20-51-0-8-9", "path20-40-68-3-3", "path20-84-1-9-4", "path20-51-7-3-4", "path20-40-4-9-0", "path20-84-3-6-5", "path20-51-99-7-9", "path20-40-2-99-6", "path20-84-5-7-3", "path20-51-9-69-4", "path20-40-6-3-2", "path20-84-8-5-8", "path20-51-0-67", "path20-40-68-7", "path20-84-1-2", "path20-51-7-29", "path20-40-4-4", "path20-84-3-1", "path20-51-99-96", "path20-40-2-9", "path20-84-5-82", "path20-51-9-5", "path20-40-6-54", "path20-84-8-9", "path20-51-0", "path20-40-68", "path20-84-1", "path20-51-7", "path20-40-4", "path20-84-3", "path20-51-99", "path20-40-2", "path20-84-5", "path20-51-9", "path20-40-6", "path20-84-8", "path20-51-0-2", "path20-40-68-2", "path20-84-1-8", "path20-51-7-2", "path20-40-4-8", "path20-84-3-9", "path20-51-99-0", "path20-40-2-7", "path20-84-5-8", "path20-51-9-1", "path20-40-6-5", "path20-84-8-8", "path20-51-0-25", "path20-40-68-8", "path20-84-1-6", "path20-51-7-26", "path20-40-4-5", "path20-84-3-3", "path20-51-99-9", "path20-40-2-2", "path20-84-5-4", "path20-51-9-6", "path20-40-6-1", "path20-84-8-82", "path20-51-0-6", "path20-40-68-29", "path20-84-1-5", "path20-51-7-20", "path20-40-4-0", "path20-84-3-39", "path20-51-99-1", "path20-40-2-8", "path20-84-5-1", "path20-51-9-9", "path20-40-6-53", "path20-84-8-2", "path20-51-4", "path20-40-9", "path20-84-6", "path20-51-3", "path20-40-83", "path20-84-7", "path20-51-8", "path20-40-8", "path20-84-0", "path20-51", "path20-40", "path20-84", "path20-9", "path20-80", "path20-182", "path20-733", "path20-16", "path20-73", "path20-15", "path20-0", "path20-3", "path20-78", "path20-18", "path20-44", "path20-61", "path20-65", "path20-86", "path20-8", "path20-77", "path20-13", "path20-12", "path20-7", "path20-6", "path20-1", "path20-4", "path20-5", "path20", "path20-07", "path20-40-4-9-82", "conf1", "conf2", "mg1", "mg2", "mg3", "beer1", "beer2", "beer4", "beer5", "beer6", "beer7", "beer8", "beer9", "beer10", "beer11", "masaj", "pool1", "pool2", "party"]

const beers = objects.filter(name => name.toLowerCase().includes("beer"));
const mgs = objects.filter(name => name.toLowerCase().includes("mg"));
const confs = objects.filter(name => name.toLowerCase().includes("conf"));
const pools = objects.filter (name => name.toLowerCase().includes("pool"));
const scaune = objects.filter (name => name.toLowerCase().includes("path"));
const masage = ["masaj"]
const parties = ["party"]

const hoverConfigs = [
    { ids: scaune, className: "hover-seat" },
    { ids: beers, className: "hover-beer" },
    { ids: mgs, className: "hover-mg" },
    { ids: confs, className: "hover-conf" },
    { ids: pools, className: "hover-pool" },
    { ids: masage, className: "hover-masage" },
    { ids: parties, className: "hover-party" }
];

const BOOKABLE_IDS = [...new Set(objects)];
const BOOKING_ENDPOINTS = {
    availability: (cssId, date) => {
        const params = new URLSearchParams({
            date: date || new Date().toISOString().split("T")[0]
        });
        return `/api/availability/${encodeURIComponent(cssId)}/?${params.toString()}`;
    },
    book: "/api/book/"
};

const getCookie = name => {
    const value = document.cookie
        .split(";")
        .map(chunk => chunk.trim())
        .find(chunk => chunk.startsWith(`${name}=`));
    if (!value) {
        if (name === "csrftoken") {
            return document.querySelector('meta[name="csrf-token"]')?.content || null;
        }
        return null;
    }
    return decodeURIComponent(value.split("=").slice(1).join("="));
};

console.log (beers, mgs, confs, pools, scaune, masage, parties)

const cleanInlineColor = (element) => {
    element.removeAttribute("fill");
    element.removeAttribute("opacity");
    if (element.style) {
        element.style.removeProperty("fill");
        element.style.removeProperty("opacity");
    }
};

const applyHoverClass = ({ ids, className }) => {
    [...new Set(ids)].forEach(id => {
        const element = document.getElementById(id);
        if (!element) {
            return;
        }

        cleanInlineColor(element);
        element.classList.add(className);
    });
};

const enableHoverEffects = () => {
    hoverConfigs.forEach(applyHoverClass);
};

const initBookingExperience = () => {
    const popover = document.getElementById("bookingPopover");
    if (!popover) {
        return;
    }

    const slotContainer = popover.querySelector("[data-role='slots']");
    const messageEl = popover.querySelector("[data-role='message']");
    const titleEl = popover.querySelector("[data-role='title']");
    const typeEl = popover.querySelector("[data-role='type']");
    const dateEl = popover.querySelector("[data-role='date']");
    const dateInput = popover.querySelector("[data-role='date-picker']");
    const closeBtn = popover.querySelector("[data-role='close']");
    const loginUrl = popover.dataset.loginUrl || document.body?.dataset?.loginUrl || "/login/";

    const todayISO = () => new Date().toISOString().split("T")[0];

    const state = {
        activeId: null,
        lastData: null,
        selectedDate: todayISO()
    };

    const setDateState = isoDate => {
        const normalized = isoDate || todayISO();
        state.selectedDate = normalized;
        if (dateInput) {
            dateInput.value = normalized;
        }
        if (dateEl) {
            dateEl.textContent = new Date(normalized).toLocaleDateString(undefined, {
                weekday: "long",
                day: "2-digit",
                month: "short",
                year: "numeric"
            });
        }
    };

    const hidePopover = () => {
        popover.classList.remove("visible");
        state.activeId = null;
        state.lastData = null;
    };

    closeBtn?.addEventListener("click", hidePopover);

    document.addEventListener("keydown", event => {
        if (event.key === "Escape") {
            hidePopover();
        }
    });

    document.addEventListener("click", event => {
        if (!popover.classList.contains("visible")) {
            return;
        }
        if (popover.contains(event.target)) {
            return;
        }
        if (event.target.closest(".bookable-target")) {
            return;
        }
        hidePopover();
    });

    const openPopover = cssId => {
        state.activeId = cssId;
        setDateState(dateInput?.value || state.selectedDate);
        popover.classList.add("visible");
        fetchAvailability(cssId);
    };

    dateInput?.addEventListener("change", () => {
        setDateState(dateInput.value);
        if (state.activeId) {
            fetchAvailability(state.activeId);
        }
    });

    BOOKABLE_IDS.forEach(id => {
        const element = document.getElementById(id);
        if (!element) {
            return;
        }
        element.style.cursor = "pointer";
        element.classList.add("bookable-target");
        element.addEventListener("click", event => {
            event.preventDefault();
            event.stopPropagation();
            openPopover(id);
        });
    });

    const setLoading = message => {
        messageEl.textContent = message;
        slotContainer.innerHTML = "";
        titleEl.textContent = "Loading...";
        typeEl.textContent = "";
        setDateState(state.selectedDate);
    };

    const fetchAvailability = async (cssId, { silent = false } = {}) => {
        if (!silent) {
            setLoading("Loading available slots...");
        }
        try {
            const response = await fetch(BOOKING_ENDPOINTS.availability(cssId, state.selectedDate));
            if (!response.ok) {
                throw new Error("Could not fetch availability.");
            }
            const data = await response.json();
            if (cssId !== state.activeId) {
                return;
            }
            state.lastData = data;
            renderAvailability(data);
        } catch (error) {
            messageEl.textContent = error.message || "Something went wrong.";
            slotContainer.innerHTML = "";
        }
    };

    const renderAvailability = data => {
        state.selectedDate = data.date;
        setDateState(data.date);
        typeEl.textContent = data.object.tip_obiect;
        titleEl.textContent = `${data.object.tip_obiect}_id${data.object.id}`;
        messageEl.innerHTML = data.is_authenticated
            ? "Pick a time slot to reserve."
            : `Please log in to reserve (<a href="${loginUrl}">Login</a>).`;

        slotContainer.innerHTML = "";

        data.slots.forEach(slot => {
            const button = document.createElement("button");
            button.type = "button";
            button.textContent = slot.time;
            button.className = "booking-popover__slot";

            if (!slot.available) {
                button.disabled = true;
                button.classList.add("booking-popover__slot--busy");
                if (slot.owned) {
                    button.classList.remove("booking-popover__slot--busy");
                    button.classList.add("booking-popover__slot--owned");
                    button.title = "This slot is already yours.";
                }
            } else if (!data.is_authenticated) {
                button.disabled = true;
            } else {
                button.addEventListener("click", () => submitBooking(slot.time));
            }

            slotContainer.appendChild(button);
        });
    };

    const submitBooking = async timeLabel => {
        if (!state.lastData) {
            return;
        }
        messageEl.textContent = "Rezervam intervalul...";
        try {
            const response = await fetch(BOOKING_ENDPOINTS.book, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": getCookie("csrftoken") || ""
                },
                body: JSON.stringify({
                    css_id: state.lastData.object.css_id,
                    date: state.selectedDate,
                    time: timeLabel
                })
            });
            const payload = await response.json();
            if (!response.ok) {
                throw new Error(payload.error || "Booking failed.");
            }
            messageEl.textContent = payload.message || "Reservation confirmed!";
            await fetchAvailability(state.lastData.object.css_id, { silent: true });
        } catch (error) {
            messageEl.textContent = error.message || "Something went wrong.";
        }
    };
};

const PAN_STEP = 70;
const SMOOTHING_FACTOR = 1;
const MAX_HORIZONTAL_RANGE = 1890;
const MAX_VERTICAL_RANGE = 920;
const INITIAL_OFFSET_X = 500;
const INITIAL_OFFSET_Y = -500;
const clampValue = (value, min, max) => Math.min(max, Math.max(min, value));

const createPanState = (svgElement, stageElement) => {
    let offsetX = INITIAL_OFFSET_X;
    let offsetY = INITIAL_OFFSET_Y;
    let targetX = offsetX;
    let targetY = offsetY;
    let animationFrame = null;

    const measureBounds = () => {
        const stageRect = stageElement.getBoundingClientRect();
        const svgRect = svgElement.getBoundingClientRect();
        const availableX = Math.max(svgRect.width - stageRect.width, 0);
        const availableY = Math.max(svgRect.height - stageRect.height, 0);
        return {
            minX: -Math.min(availableX, MAX_HORIZONTAL_RANGE),
            maxX: -220,
            minY: -Math.min(availableY, MAX_VERTICAL_RANGE),
            maxY: -600
        };
    };

    const render = () => {
        svgElement.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
    };

    const stepAnimation = () => {
        const dx = targetX - offsetX;
        const dy = targetY - offsetY;
        const closeEnough = Math.abs(dx) < 0.2 && Math.abs(dy) < 0.2;
        if (closeEnough) {
            offsetX = targetX;
            offsetY = targetY;
            render();
            animationFrame = null;
            return;
        }
        offsetX += dx * SMOOTHING_FACTOR;
        offsetY += dy * SMOOTHING_FACTOR;
        render();
        animationFrame = window.requestAnimationFrame(stepAnimation);
    };

    const ensureAnimation = () => {
        if (animationFrame === null) {
            animationFrame = window.requestAnimationFrame(stepAnimation);
        }
    };

    const clampTargets = () => {
        const { minX, maxX, minY, maxY } = measureBounds();
        targetX = clampValue(targetX, minX, maxX);
        targetY = clampValue(targetY, minY, maxY);
    };

    const pan = (deltaX, deltaY) => {
        targetX += deltaX;
        targetY += deltaY;
        clampTargets();
        ensureAnimation();
    };

    const refresh = () => {
        clampTargets();
        ensureAnimation();
    };

    const initializePosition = () => {
        clampTargets();
        offsetX = targetX;
        offsetY = targetY;
        render();
    };

    initializePosition();

    return { pan, refresh };
};

const initPanControls = () => {
    const svgElement = document.querySelector(".inline-svg");
    const stageElement = document.querySelector(".svg-stage");
    const panButtons = document.querySelectorAll("[data-pan]");
    if (!svgElement || !stageElement) {
        return;
    }

    const panState = createPanState(svgElement, stageElement);
    window.addEventListener("resize", panState.refresh);

    const panOffsets = {
        up: { x: 0, y: PAN_STEP },
        down: { x: 0, y: -PAN_STEP },
        left: { x: PAN_STEP, y: 0 },
        right: { x: -PAN_STEP, y: 0 }
    };

    const getEventPoint = event => {
        if (event.touches && event.touches.length) {
            return { x: event.touches[0].clientX, y: event.touches[0].clientY };
        }
        return { x: event.clientX, y: event.clientY };
    };

    let isDragging = false;
    let lastPoint = null;

    const startDrag = event => {
        if (event.button !== undefined && event.button !== 0) {
            return;
        }
        event.preventDefault();
        isDragging = true;
        svgElement.classList.add("dragging");
        lastPoint = getEventPoint(event);
    };

    const handleDrag = event => {
        if (!isDragging || !lastPoint) {
            return;
        }
        event.preventDefault();
        const point = getEventPoint(event);
        const deltaX = point.x - lastPoint.x;
        const deltaY = point.y - lastPoint.y;
        lastPoint = point;
        panState.pan(deltaX, deltaY);
    };

    const stopDrag = () => {
        if (!isDragging) {
            return;
        }
        isDragging = false;
        svgElement.classList.remove("dragging");
        lastPoint = null;
    };

    svgElement.addEventListener("mousedown", startDrag);
    svgElement.addEventListener("touchstart", startDrag, { passive: false });
    window.addEventListener("mousemove", handleDrag);
    window.addEventListener("touchmove", handleDrag, { passive: false });
    window.addEventListener("mouseup", stopDrag);
    window.addEventListener("touchend", stopDrag);
    window.addEventListener("touchcancel", stopDrag);

    const attachPanInteraction = (button, movement) => {
        const panStep = () => panState.pan(movement.x, movement.y);
        let holdTimer = null;

        const startHold = event => {
            event.preventDefault();
            if (holdTimer !== null) {
                return;
            }
            panStep();
            holdTimer = window.setInterval(panStep, 70);
        };

        const stopHold = () => {
            if (holdTimer === null) {
                return;
            }
            window.clearInterval(holdTimer);
            holdTimer = null;
        };

        button.addEventListener("mousedown", startHold);
        button.addEventListener("touchstart", startHold, { passive: false });
        ["mouseup", "mouseleave"].forEach(evt => button.addEventListener(evt, stopHold));
        ["mouseup", "touchend", "touchcancel"].forEach(evt => window.addEventListener(evt, stopHold));
        button.addEventListener("touchend", stopHold);
        button.addEventListener("touchcancel", stopHold);
        button.addEventListener("blur", stopHold);
        button.addEventListener("keydown", event => {
            if (event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                panStep();
            }
        });
    };

    panButtons.forEach(button => {
        const movement = panOffsets[button.dataset.pan];
        if (!movement) {
            return;
        }
        attachPanInteraction(button, movement);
    });

    document.addEventListener("keydown", event => {
        const keyToDirection = {
            ArrowUp: "up",
            ArrowDown: "down",
            ArrowLeft: "left",
            ArrowRight: "right"
        };
        const direction = keyToDirection[event.key];
        if (!direction) {
            return;
        }
        const movement = panOffsets[direction];
        if (!movement) {
            return;
        }
        event.preventDefault();
        panState.pan(movement.x, movement.y);
    });
};

const startClock = () => {
    const clockRoot = document.getElementById("navClock");
    if (!clockRoot) {
        return;
    }
    const dateEl = clockRoot.querySelector(".nav__clock-date");
    const timeEl = clockRoot.querySelector(".nav__clock-time");

    const render = () => {
        const now = new Date();
        const dateFormatter = new Intl.DateTimeFormat(undefined, {
            weekday: "short",
            day: "2-digit",
            month: "short"
        });
        const timeFormatter = new Intl.DateTimeFormat(undefined, {
            hour: "2-digit",
            minute: "2-digit"
        });
        if (dateEl) {
            dateEl.textContent = dateFormatter.format(now).toUpperCase();
        }
        if (timeEl) {
            timeEl.textContent = timeFormatter.format(now);
        }
    };

    render();
    return window.setInterval(render, 60_000);
};

document.addEventListener("DOMContentLoaded", () => {
    enableHoverEffects();
    initBookingExperience();
    initPanControls();
    startClock();
});
